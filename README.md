## <h4> Решение задачи Коши с заданной точностью с автоматическим выбором максимальной длины шага.
Зная диф. ур. и начальное условие можно получить все значения функции. </h4>

[посмотреть полный отчёт](https://github.com/NIOHOMY/Numerical_Methods_6_semester/blob/master/otchyot_3_kurs_62_gruppa_1_podgruppa_PakhomovaPV-2.pdf)

<h1>
Постановка задачи  
</h1>

![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/918018f4-4ea9-46f1-97a8-8fc47fcf726e)

Входные параметры: <br/>

* data – имя файлаисходных данных;
* f – имя п роцедуры – функции с двумя параметрами, которая должна быть описана в программе (функция f – вычисляет значение правой части уравнения (1));
* rez имя файла выходных данных.

 Вaходные параметры: <br/>

* Первая и последующие строки -x координата точки интегрирования;
* Полученное приближенное значение в этой точке, погрешность в этой точке;
* Последняя строка файла число точек интегрирования;
* число точек, в которых не достигается заданная точность;
* общее количество минимальных шагов интегрирования.

<h1>
Алгоритм 
</h1>

1. Начинаем функцию integrate()
* Она очищает файл для записи данных. 
* Запускает цикл while, который продолжается, пока переменная flagEnd не 
станет истинной
* После функция записывает число точек, число точек, в которых не 
достигается заданная точность, общее количество минимальных шагов 
интегрирования .
  * В каждой итерации цикла вызывается функция calculateNext().

2. Функция getNextX() определяет следующее значение curX (текущего x) в соответствии с некоторыми условиями
* Если шаг h положительный, проверяется, чтобы B - (curX + h) было больше 
чем hMin. Если это условие выполняется, curX увеличивается на h.
* Если условие не выполняется, значение tmpX устанавливается равным 
текущему curX. <br/>
Затем проверяются различные условия:
  * Если B - curX больше или равно 2.0 * h, это означает, что мы находимся 
  на предпоследнем шаге, и устанавливаем curX в B h.
  * Если B - curX находится в диапазоне от 1.5 * h до 2.0 * h (или flagLastStep 
  истинен), это означает, что мы находимся на последнем шаге, и 
  устанавливаем curX в B.
  * Если B - curX находится между 1.5 * h и 2.0 * h (или flagLastStep ложен), 
  мы устанавливаем curX в значение, равное текущему curX плюс 
  половину разницы между B и curX.
  * h затем устанавливается равным разнице между текущим curX и tmpX.
* Если шаг h отрицательный, происходит процедура, но с условиями, 
проверяющими, чтобы A - (curX + h) было больше чем hMin, остальные 
действия аналогичны

3. Функция calculateNext() выполняет следующие действия в цикле do-while
* Увеличивает счетчик hMinCount, если h равно hMin.
* Запоминает текущее значение curX в переменной tmpX.
* Вызывает getNextX() для определения следующего значения curX.
* Вычисляет значения k1_y, k2_y, k2_E и k3_E на основе текущих значений C и yC. <br/>
k1_y, k2_y формула (20) k2_E, k3_E формула (30) <br/>
* Для вычисления используется значение функции:<br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/d71b408a-d8c7-4f52-bf75-9a624719baff)
* Вычисляет текущее значение curY как<br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/40792ee2-2102-4e84-9c69-83e6a2378eea)
* Вычисляет текущее значение acurY как<br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/22e633f4-16a9-4e6c-a43b-2714b5e35a5f)
* Вычисляет текущее значение curE как разницу между acurY и curY.
* Проверяет условия для изменения шага h:
  * Если абсолютное значение curE равно нулю или меньше E / k и isDivision 
  ложно, удваивает h.
  * Проверяет, если значение curE больше E, и если да, проверяет условия для
  деления шага:
    * Если h не равно hMin, устанавливает isDivision в истину, возвращает 
    curX к предыдущему значению tmpX, и устанавливает h равным 
    половине его предыдущего значения или hMin, если абсолютное 
    значение hMin больше или равно абсолютному значению половины 
    предыдущего h.
    * Если h равно hMin, увеличивает счетчик incorrectXCount и добавляет 
    узел с текущими значениями curX, curY и curE.
  * Если ни одно из условий не выполняется, добавляет узел с текущими 
значениями curX, curY и curE

4. Функция addNode()
* открывает файл для записи
* добавляет строку с текущими значениями x, y и E
* закрывает файл 
* Обновляет значения yC и C для следующей итерации


<h1>
Тестирование 
</h1>

![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/ca1c6360-a006-4efe-96a9-584f6ceba899) <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/1bdfbaa1-c718-4f67-b89b-3a682bb900cc) <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/e8457e33-d5b6-4b38-8cf5-f5c920ff25d0) <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/edec7d91-35b8-4eb1-9280-fa8d6a219e33) <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/dcf755ec-a9e9-47b8-bae3-f50bc316638c) <br/>




