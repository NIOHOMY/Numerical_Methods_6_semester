## <h4> Решение линейной краевой задачи для дифференциального уравнения второго порядка методом универсальной дифференциальной прогонки. </h4>

[посмотреть полный отчёт](https://github.com/NIOHOMY/Numerical_Methods_6_semester/blob/master/otchyot_3_kurs_62_gruppa_1_podgruppa_PakhomovaPV-3.pdf)

<h1>
Постановка задачи  
</h1>

![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/95178be0-6015-419e-9dbc-a8502cf07f89)

Входные параметры: <br/>

* data - имя файла исходных данных;
* p, q, f - имена процедур-функций с одним параметром, которые должны быть описаны в основной программе (функции p(x), q(x),
* f(x) вычисляют значения коэффициентов уравнения (4.2)); <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/6eadfaae-6e72-4ad4-9e6c-817e322cfb93) <br/>
* rez - имя файла выходных данных.

Выходные параметры: <br/>

* Первая строка – значения коэффициентов граничных условий.
* Вторая строка – значения левого и правого концов отрезка интегрирования, количество точек в заданной сетке узлов.
* Строки с третьей и далее – номер узла, значение аргумента x в узле.

> Первая и последующие строки содержат номер точки, ее x - координату,
значение вычисленного решения и значение производной решения в этой точке.
Никакого анализа точности полученных результатов не предполагается.
Для решения использовать метод Рунге-Кутта

<h1>
Алгоритм 
</h1>

Разберем шаги и функции по частям.
1. Функция solve()
 - Создается файл для записи результатов.
 - Вызываются функции solveFirstSystem(), solveSecondSystem() и 
solveUVWABYSystem() для решения систем уравнений.
2. Функция solveFirstSystem()
 - Инициализируются начальные значения u0, v0 и w0.
 - Значения добавляются в списки uValues, vValues и wValues.
 - В цикле вычисляются новые значения переменных с помощью формул, 
содержащих параметры p, q и f (функции зависящие от x).
 - Формулы для вычисления новых значений: <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/90a6e838-13e8-4966-a789-e2d53d79c00d) <br/>
- Вычисление значений ui, vi, wi происходит в getFValues()

3. Функция getFValues()
 - Принимает начальное значение _f0, формулу fi, номер итерации i и флаг isBack.
 - В зависимости от значения флага isBack определяются значения A, B и C.
 - Создается объект IntegrationOrdinaryDifferentialEquation для решения 
дифференциального уравнения.
 - Результаты интеграции парсятся и возвращается полученное значение 
функции.

4. Формула для интеграции 
- Непосредственная формула интегрирования определена в классе 
IntegrationOrdinaryDifferentialEquation. В ней используется метод Рунге-Кутты для 
вычисления значений. <br/>

5. Функция solveSecondSystem()
- Шаги и вычисления аналогичны solveFirstSystem(), но вычисления идут с конца 
отрезка до его начала.

6. Функция solveEquationSystemUVWABY:
- Инициализация переменных и функции определителя:
   - Определяется функция det, которая вычисляет определитель матрицы 2x2.
   - Вычисляются значения D, D1 и D2 как определители матрицы, используя 
  входные параметры функции.
- Проверка на невырожденность системы:
   - Проверяется, что определитель D не равен 0. Если равен, функция возвращает 
  null и система решения не имеет, иначе продолжает вычисления.
- Вычисление решения системы:
   - Вычисляются значения x1 (y') и x2 (y) как результат деления соответствующих
  определителей на D.
   - Возвращается пара значений (x1 (y'), x2 (y)).

7. функция solveUVWABYSystem:
- Итерация по данным:
   - Устанавливается начальное значение счетчика i=0.
   - В цикле выполняются следующие действия для каждого элемента данных до 
  достижения data.N из входных параметров:
- Решение системы и запись результатов:
   - Для текущего индекса i вызывается функция solveEquationSystemUVWABY, 
  передавая соответствующие значения из списков uValues, vValues, wValues, aValues, 
  bValues и yValues.
  - Если решение не равно null, то результат записывается с помощью функции 
  writeToOut, передавая узел данных data.nodeValues[i] (значения xi, i=0,N) и значения 
  решения (y, y')

<h1>
Тестирование 
</h1>

![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/2b6615e0-0e32-404b-a694-83d4a67afa48) <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/fc359554-c4ed-43ba-92db-eecb30de97a8) <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/573d8ddf-91fc-4356-b35f-3adc78e172f5) <br/>
![image](https://github.com/NIOHOMY/Numerical_Methods_6_semester/assets/38347892/b7da1762-27d4-4059-b3fc-68dcd6178bea) <br/>


<h1>
Вывод 
</h1>

Размер сетки влияет на точность значений функции и ее производных.
В общем случае, чем меньше размер сетки, тем точнее аппроксимация значений 
функции и ее производных. Это связано с тем, что небольшой размер сетки лучше 
улавливает локальные изменения функции, повышая тем самым точность 
аппроксимации. Однако слишком малый размер сетки также увеличивает 
вычислительные усилия и требования к хранению данных, что может привести к 
снижению эффективности вычислений.
> Однако, в некоторых задачах уменьшение размера сетки может не привести к 
значительному повышению точности
